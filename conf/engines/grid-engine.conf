##################################################################
# smartmet-engine-grid
##################################################################

# This is a configuration file used by the module
# smartmet-engine-grid. The SmartMet server's configuration
# file for the "grid" engine should point to this file.

##################################################################

# Importing global configuration parameters. There should be
# an environment variable SMARTMET_ENV_FILE that points to
# the global configuration file. The idea is that you can easily
# change your environment by editing this file.

smartmet :
{
library :
{

grid-files :
{
  # Processing of grid/grib files requires a lot of configuration information.
  # This information should be found from the file below.

  configFile = "/config/libraries/grid-files/grid-files.conf"

  # If the data server is local then the grid file cache can be used to improve
  # performance. This cache is used caching uncompressed grid data. When the cache 
  # is full then the oldest data is automatically removed. The data that is packed
  # with "simple packing" method is not cached.

  memoryMapper :
  {
    enabled = true
    #accessFile = "%(DIR)/access.csv"
    premapEnabled = true;
  }
    
  cache :
  {
    numOfGrids         = 50000
    maxSizeInMegaBytes = 30000
  }
   
}

} # library


engine :
{
grid :
{
  # The usage of the grid-engine can be enabled/disabled
  
  enabled = true


# The content server defines the source of the content information. In practice,
# the master source of the content information is the Redis database. However,
# it is not fast enough for our purposes. That's why its information is cached
# to a memory based content server. This cache server can be a remote content
# server that is used over CORBA connection, or it can be embedded ("local") into
# the grid engine. The cache content server is very fast but it uses a lot of
# memory. That's why it usually makes sense to use the remote cache server if
# that is possible. On the other hand this means that the grid engine can
# start much faster because it does not need to cache content information first.

content-server :
{
  content-source : 
  {
    # Content source type (redis/corba/http/file)

    type = "redis"

    redis :
    {
      address           = "$(REDIS_CONTENT_SERVER_ADDRESS)"
      port              = $(REDIS_CONTENT_SERVER_PORT)
      tablePrefix       = "$(REDIS_CONTENT_SERVER_TABLE_PREFIX)"
      lockEnable        = false;
      reloadRequired    = true;

    # Grid files can be released from the memory if they are not accessed in a given time (= age in seconds). 
    # This feature is useful especially with archive installations that might contains millions of 
    # grids, which are rarely accessed.
    
    clean-up :
    {
      age = 360000
      checkInterval = 3600  
    }    
  }

    corba :
    {
      ior          = ""
    }

    http :
    {
      url          = ""
    }
    
    file :
    {
      # This selection means in practice that a memory-based contentServer is embedded into the grid-engine.
      # It gets its content information from CSV-files that can be found from the "contentDir". It monitors 
      # the state of these files and automatically updates changes into its memory structures.  Notice that
      # if this content source is selected then there is no need use for the local cache.

#      contentDir          = "/var/smartmet/grid/"
      contentDir          = "/tmp/"
      
     
      # Size of the event list. If there are no local cache then this size should be 0.
      # Otherwise it should be quite big (1000000 - 5000000) 
    
      eventListMaxSize = 0                   
    }      
    
  }

  processing-log :
  {
    enabled      = false
    file         = "/dev/stdout"
    maxSize      = 100000000
    truncateSize = 20000000
  }

  debug-log :
  {
    enabled      = false
    file         = "/dev/stdout"
    maxSize      = 100000000
    truncateSize = 20000000
  }

  cache :
  {
    enabled	= true

    # Should the get requests be forwarded to the original content source when the cache update is in progress 

    requestForwardEnabled = false   
    
    # Fast searches require that content information is sorted. However, it is usually a little bit difficult to update
    # this kind of structure in real-time so that it does not slow down search requests, especially when there are several      
    # updates and hundreds of parallel requests going on at the same time. In this case we should use content swapping.  
    # The idea is that we have two different structures: the first one is used for continious updates and the second one 
    # is used for searches. So the first structure is always up to date and we do not use it for searches. However, we 
    # swap this structure to the search structure time to time (=> contentUpdateInterval). This kind of swapping is 
    # very fast operation and does not cause any significant breaks for searches.
    
    # Notice that the content swapping increases the memory consumtion a little bit. You do not need to use it
    # if your content is not continuously updated.  
           
    contentSwapEnabled = true
    
    contentUpdateInterval = 180

 }
}



# The data server is responsible for fetching actual data from the grid files. It is possible
# to use a local or a remote data server. The data server uses also a lot of memory and maps
# grid files into virtual memory. That's why it would be smarter to use shared data servers
# when possible. On the other hand, the remote data server is usually always up and running
# which means that it can be used immediately. If the data server is local then it
# takes some time to start the system and make sure that all grid files are available.
# If the remote data server is disabled then the local data server is used in the engine.

data-server :
{
  ######  The remote data server. Notice that the remote data server has its own configuration file.

  remote  = false
  caching = false
  ior     = ""


  ######  The local data server. These settings are valid when the "remote" attribute is "false".

  # Location of grid files.

  grid-storage :
  {
    directory = "$(GRID_FILE_STORAGE_DIR)"
    memoryMapCheckEnabled = false
    preloadEnabled = false
    preloadMemoryLock = false
    preloadFile = "%(DIR)/grid-engine/preload.csv" 
    
    # Grid files can be released from the memory if they are not accessed in a given time (= age in seconds). 
    # This feature is useful especially with archive installations that might contains millions of 
    # grids, which are rarely accessed.
    
    clean-up :
    {
      age = 3600
      checkInterval = 300  
    }        
  }


  # The data server can generate "virtual grid files" that are based on
  # existing grid files. The definition file is used in order to define
  # requirements (= required parameters) and rules (= LUA function) for
  # new virtual files.

  # TODO this crashes the server if file is missing even if enabled=false

  virtualFiles :
  {
    enabled = false
    definitionFile = "%(DIR)/grid-engine/vff_convert.csv"
  }

  # LUA files are usually needed for generating content for the virtual
  # files. In practice, each virtual file definition contains the name
  # of the LUA function that needs to be called when the data of
  # the current virtual file is requested.

  luaFiles =
  [
    "%(DIR)/grid-engine/vff_convert.lua"
  ];

  processing-log :
  {
    enabled      = false
    file         = "/dev/stdout"
    maxSize      = 100000000
    truncateSize = 20000000
  }

  debug-log :
  {
    enabled      = false
    file         = "/dev/stdout"
    maxSize      = 100000000
    truncateSize = 20000000
  }
}


# The query server is responsible for making data queries to the data server according
# to the content information that it gets from the content server. Also the query server
# can be local or remote. Sometimes it is smarter to locate the query server closer to
# the content server and the data server, because there might be a lot traffic between them.
# If the remote query server is disabled then the local query server is used in the engine.

query-server :
{
  remote  = false
  ior     = ""

  
  # If you want to search data from a certain producer then this producer must be listed in 
  # this file. On the other hand, this file defines the search order of the producers and geometries 
  # in the case of that the producer or the geometry is not defined.  

  producerFile = "/config/engines/grid-engine/producers.csv"
    
  producerStatusFile = "%(DIR)/grid-engine/stat_newbase_producers.cfg"  

  # The producer mapping files are used for mapping newbase producers and parameters to the correct
  # grib producers, gemetries and level types. 

  producerMappingFiles = 
  [
    # #"%(DIR)/grid-engine/pm_ecmwf_eurooppa_mallipinta.cfg",
    # #"%(DIR)/grid-engine/pm_ecmwf_eurooppa_painepinta.cfg",
    # #"%(DIR)/grid-engine/pm_ecmwf_eurooppa_pinta.cfg",
    # #"%(DIR)/grid-engine/pm_ecmwf_europe_probability.cfg",
    # #"%(DIR)/grid-engine/pm_ecmwf_maailma_mallipinta.cfg",
    # #"%(DIR)/grid-engine/pm_ecmwf_maailma_painepinta.cfg",
    # "%(DIR)/grid-engine/pm_ecmwf_maailma_pinta.cfg",
    # #"%(DIR)/grid-engine/pm_gfs.cfg",
    # #"%(DIR)/grid-engine/pm_harmonie_scandinavia_surface.cfg",
    # "%(DIR)/grid-engine/pm_pal_skandinavia.cfg",
    # "%(DIR)/grid-engine/pm_mos_eurooppa_pinta.cfg",
    # "%(DIR)/grid-engine/pm_smartmet_nowcast_scandinavia_surface.cfg"    
  ];

  queryCache :
  {
    # A query object is removed from the cache if it accessed in this time (seconds). 
    
    enabled = false
    maxAge = 3600
  }

  
  contentCache:
  {  
    maxRecordsPerThread = 100000
    clearInterval = 36000
  }
  
  contentSearchCache:
  {  
    maxRecordsPerThread = 100000
    clearInterval = 36000
  }

  # If the gridEngine notices that there are not valid mappings available for all
  # parameters found from the contentServer, then it automatically adds these unmapped
  # parameters to the following files. The queryServer needs these mappings in order to
  # find the current parameters. You can move these automatically generated mappings into
  # a more permanent mapping file (mappings_fmi_auto.csv => mappings_fmi.csv). On the other
  # hand, when the permanent mapping files are empty then you can get your basic mapping
  # settings from these automatically generated files (i.e. when you are first time
  # configuring your system).


  # 1 = FMI_ID, 2 = FMI_NAME, 3 = GRIB_ID, 4 = NEWBASE_ID, 5 = NEWBASE_NAME, 6 = CDM_ID, 7 = CDM_NAME

  mappingTargetKeyType = 2

  mappingUpdateFile :
  {
    fmi     = "/var/smartmet/grid/mapping_fmi_auto.csv"
    newbase = "/var/smartmet/grid/mapping_newbase_auto.csv"
    netCdf  = "/var/smartmet/grid/mapping_netCdf_auto.csv"
  }

  luaFiles =
  [
    # "%(DIR)/grid-engine/function_basic.lua",
    # "%(DIR)/grid-engine/function_interpolation.lua",
    # "%(DIR)/grid-engine/function_conversion.lua",
    # "%(DIR)/grid-engine/function_newbase.lua",
    # "%(DIR)/grid-engine/function_demo.lua",
    # "%(DIR)/grid-engine/function_railrule5.lua"
  ];

  mappingFiles =
  [
   "/config/libraries/mappings/mapping_fmi.csv",
   "/var/smartmet/grid/mapping_fmi_auto.csv",
    # "%(DIR)/grid-engine/mapping_newbase.csv",
    # "/var/smartmet/grid/mapping_newbase_auto.csv",
    # "%(DIR)/grid-engine/mapping_virtual.csv",
    # "%(DIR)/grid-engine/mapping_netCdf.csv",
    # "/var/smartmet/grid/mapping_netCdf_auto.csv",
  ];

  aliasFiles =
  [
    # "%(DIR)/grid-engine/alias_demo.cfg",
    # "%(DIR)/grid-engine/alias_newbase_extension.cfg"
  ];

  processing-log :
  {
    enabled      = false
    file         = "/dev/stdout"
    maxSize      = 100000000
    truncateSize = 20000000
  }

  debug-log :
  {
    enabled      = false
    file         = "/dev/stdout"
    maxSize      = 100000000
    truncateSize = 20000000
  }
}

# smartmet-plugin-grid-admin can browse information in the grid engine. 

browser :
{
  enabled  = true
  
  # This field is used for defining permissions for the browsing. Permissions are
  # expressed with bits (0 = disabled, 1 = enabled)
  # 
  #   bit 0 : Content modification
  #   bit 1 : Log modification
  
  flags    = 1
}

}
}
}
